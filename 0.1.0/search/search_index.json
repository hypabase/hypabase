{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hypabase","text":"<p>Hypabase is a Python library for storing and querying relationships between entities. A single edge connects two or more nodes, every edge tracks where it came from (<code>source</code> and <code>confidence</code>), and the whole graph lives in a local SQLite file with no server or configuration.</p> <p>Use it to build knowledge graphs, retrieval-augmented generation pipelines, and structured agent memory. Recent research explores hypergraph representations for these tasks:</p> <ul> <li>HyperGraphRAG \u2014 n-ary knowledge retrieval across medicine, agriculture, CS, and law</li> <li>Cog-RAG \u2014 dual-hypergraph retrieval with theme-level and entity-level recall</li> <li>Hypergraph Memory for Multi-step RAG \u2014 hypergraph-based memory for long-context relational modeling</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>uv add hypabase\n</code></pre>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>from hypabase import Hypabase\n\nhb = Hypabase(\"my.db\")  # local SQLite, zero config\n\n# One edge connecting five entities\nhb.edge(\n    [\"dr_smith\", \"patient_123\", \"aspirin\", \"headache\", \"mercy_hospital\"],\n    type=\"treatment\",\n    source=\"clinical_records\",\n    confidence=0.95,\n)\n\n# Query edges involving a node\nhb.edges(containing=[\"patient_123\"])\n\n# Find paths between entities\nhb.paths(\"dr_smith\", \"mercy_hospital\")\n</code></pre> <p>See Getting Started for the full walkthrough.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>N-ary hyperedges \u2014 an edge connects 2+ nodes in a single relationship</li> <li>O(1) vertex-set lookup \u2014 find edges by their exact node set</li> <li>Provenance \u2014 every edge carries <code>source</code> and <code>confidence</code></li> <li>Provenance queries \u2014 filter by <code>source</code> and <code>min_confidence</code>, summarize with <code>sources()</code></li> <li>SQLite persistence \u2014 local-first, zero-config</li> <li>CLI \u2014 <code>hypabase init</code>, <code>hypabase node</code>, <code>hypabase edge</code>, <code>hypabase query</code></li> <li>Python SDK \u2014 keyword args, method names read like English</li> </ul>"},{"location":"#limitations","title":"Limitations","text":"<ul> <li>No semantic similarity or fuzzy search \u2014 pair with a vector database for that (hybrid pattern)</li> <li>No declarative query language (e.g., Cypher, SPARQL) \u2014 use the Python SDK, CLI, or MCP tools</li> <li>No built-in visualization</li> <li>Early project \u2014 small community</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Getting Started \u2014 install and build your first graph</li> <li>Concepts \u2014 hypergraphs, provenance, and vertex-set indexing</li> <li>API Reference \u2014 full SDK documentation</li> </ul>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#what-is-a-hypergraph","title":"What is a hypergraph?","text":"<p>A hypergraph generalizes a graph by allowing edges to connect any number of nodes, not only two. In a regular graph, an edge connects exactly two nodes (a pair). In a hypergraph, a single hyperedge can connect 2, 3, 5, or more nodes at once.</p> <p>This matters because real-world facts are often n-ary:</p> <ul> <li>\"Dr. Smith treated Patient 123 with Aspirin for a Headache at Mercy Hospital\" \u2014 5 entities, one fact</li> <li>\"The board approved a $5M budget for APAC expansion into Japan and Korea in Q3\" \u2014 6 entities, one decision</li> <li>\"BERT builds on the Transformer architecture using pretraining\" \u2014 3 entities, one relationship</li> </ul> <p>A hypergraph represents these directly. Each example above is a single hyperedge.</p>"},{"location":"concepts/#hyperedges-vs-binary-edges","title":"Hyperedges vs binary edges","text":"<p>In a standard property graph (e.g., Neo4j), edges connect exactly two nodes. To model the board decision, you'd introduce an intermediate node:</p> <pre><code>(d:Decision)\n(board)-[:DECIDED]-&gt;(d)\n(d)-[:BUDGET]-&gt;(budget_5m)\n(d)-[:REGION]-&gt;(apac)\n(d)-[:COUNTRY]-&gt;(japan)\n(d)-[:COUNTRY]-&gt;(korea)\n(d)-[:TIMELINE]-&gt;(q3)\n</code></pre> <p>That's 6 binary edges and an intermediate node representing the decision.</p> <p>In Hypabase, a single hyperedge connects all participants:</p> <pre><code>hb.edge(\n    [\"board\", \"budget_5m\", \"apac\", \"japan\", \"korea\", \"q3\"],\n    type=\"budget_approval\",\n)\n</code></pre>"},{"location":"concepts/#nodes","title":"Nodes","text":"<p>A node represents an entity. Every node has:</p> <ul> <li><code>id</code> \u2014 unique string identifier (e.g., <code>\"dr_smith\"</code>, <code>\"patient_123\"</code>)</li> <li><code>type</code> \u2014 classification string (e.g., <code>\"doctor\"</code>, <code>\"patient\"</code>, <code>\"medication\"</code>)</li> <li><code>properties</code> \u2014 arbitrary key-value metadata</li> </ul> <p>Nodes are auto-created when referenced in an edge. If you create an edge referencing <code>\"aspirin\"</code> and no node with that ID exists, Hypabase creates it with <code>type=\"unknown\"</code>. See Getting Started for usage.</p>"},{"location":"concepts/#edges-hyperedges","title":"Edges (hyperedges)","text":"<p>An edge represents a relationship between 2 or more nodes. Every edge has:</p> <ul> <li><code>id</code> \u2014 unique identifier (auto-generated UUID if not specified)</li> <li><code>type</code> \u2014 relationship type (e.g., <code>\"treatment\"</code>, <code>\"concept_link\"</code>)</li> <li><code>incidences</code> \u2014 ordered list of node participations</li> <li><code>directed</code> \u2014 whether the edge has direction (tail/head semantics)</li> <li><code>source</code> \u2014 provenance source string</li> <li><code>confidence</code> \u2014 confidence score (0.0 to 1.0)</li> <li><code>properties</code> \u2014 arbitrary key-value metadata</li> </ul> <p>See Getting Started for usage.</p>"},{"location":"concepts/#node-order","title":"Node order","text":"<p>The <code>position</code> column in the incidence table preserves node order. The order you pass nodes is the order they're stored. This matters for directed edges and for domain-specific semantics where position carries meaning.</p>"},{"location":"concepts/#directed-edges","title":"Directed edges","text":"<p>When <code>directed=True</code>, the first node is the tail and the last node is the head:</p> <pre><code>hb.edge(\n    [\"cause\", \"intermediate\", \"effect\"],\n    type=\"causal_chain\",\n    directed=True,\n)\n</code></pre>"},{"location":"concepts/#provenance","title":"Provenance","text":"<p>Every edge carries two provenance fields:</p> <ul> <li><code>source</code> \u2014 a string identifying where the relationship came from (e.g., <code>\"clinical_records\"</code>, <code>\"gpt-4o_extraction\"</code>, <code>\"user_input\"</code>)</li> <li><code>confidence</code> \u2014 a float between 0.0 and 1.0 representing certainty</li> </ul> <p>Provenance is not bolted-on metadata \u2014 it's part of the core data model. This enables:</p> <ul> <li>Filtering edges by source or confidence threshold</li> <li>Aggregating reliability across sources</li> <li>Tracking which AI model or human produced each fact</li> <li>Building audit trails</li> </ul> <p>See the Provenance guide for context managers, overrides, and querying.</p>"},{"location":"concepts/#vertex-set-lookup","title":"Vertex-set lookup","text":"<p>Hypabase maintains a SHA-256 hash index over the node sets of all edges. This enables O(1) exact vertex-set lookup \u2014 given a set of node IDs, find all edges that connect exactly those nodes (order-independent):</p> <pre><code>edges = hb.edges_by_vertex_set([\"dr_smith\", \"patient_123\", \"aspirin\"])\n</code></pre> <p>The query answers: \"does a relationship connect exactly these entities?\"</p>"},{"location":"concepts/#storage","title":"Storage","text":"<p>Hypabase uses SQLite with WAL mode and foreign keys enabled. The database has four tables:</p> Table Purpose <code>nodes</code> Entity storage (id, type, properties) <code>edges</code> Relationship metadata (id, type, source, confidence, properties) <code>incidences</code> Junction table linking edges to nodes with position and direction <code>vertex_set_index</code> SHA-256 hash index for O(1) exact vertex-set lookup <p>The storage engine encapsulates all SQL. The client API never exposes raw queries.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"uvpip <pre><code>uv add hypabase\n</code></pre> <pre><code>pip install hypabase\n</code></pre> <p>For CLI support:</p> <pre><code>uv add \"hypabase[cli]\"\n</code></pre>"},{"location":"getting-started/#your-first-hypergraph","title":"Your first hypergraph","text":"<pre><code>from hypabase import Hypabase\n\n# File-backed database (persists to SQLite)\nhb = Hypabase(\"my.db\")\n\n# Or in-memory for experiments\nhb = Hypabase()\n</code></pre>"},{"location":"getting-started/#create-nodes","title":"Create nodes","text":"<pre><code>hb.node(\"dr_smith\", type=\"doctor\")\nhb.node(\"patient_123\", type=\"patient\")\nhb.node(\"aspirin\", type=\"medication\")\nhb.node(\"headache\", type=\"condition\")\nhb.node(\"mercy_hospital\", type=\"hospital\")\n</code></pre>"},{"location":"getting-started/#create-a-hyperedge","title":"Create a hyperedge","text":"<p>A single edge connects all five entities atomically:</p> <pre><code>hb.edge(\n    [\"dr_smith\", \"patient_123\", \"aspirin\", \"headache\", \"mercy_hospital\"],\n    type=\"treatment\",\n    source=\"clinical_records\",\n    confidence=0.95,\n)\n</code></pre> <p>Note</p> <p>Nodes referenced in an edge are auto-created if they don't exist. You can skip explicit <code>node()</code> calls if you don't need to set node types or properties upfront.</p>"},{"location":"getting-started/#query-edges","title":"Query edges","text":"<pre><code># All edges involving a patient\nedges = hb.edges(containing=[\"patient_123\"])\n\n# Edges connecting both patient and medication\nedges = hb.edges(containing=[\"patient_123\", \"aspirin\"], match_all=True)\n\n# Filter by type\nedges = hb.edges(type=\"treatment\")\n\n# Filter by provenance\nedges = hb.edges(source=\"clinical_records\")\nedges = hb.edges(min_confidence=0.9)\n</code></pre>"},{"location":"getting-started/#find-paths","title":"Find paths","text":"<pre><code>paths = hb.paths(\"dr_smith\", \"mercy_hospital\")\n# [[\"dr_smith\", ..., \"mercy_hospital\"]]\n</code></pre>"},{"location":"getting-started/#check-stats","title":"Check stats","text":"<pre><code>stats = hb.stats()\nprint(f\"Nodes: {stats.node_count}, Edges: {stats.edge_count}\")\n</code></pre>"},{"location":"getting-started/#using-provenance","title":"Using provenance","text":"<p>Every edge carries <code>source</code> and <code>confidence</code>. Set them per-edge or in bulk with a context manager:</p> <pre><code># Per-edge\nhb.edge(\n    [\"patient_123\", \"aspirin\", \"ibuprofen\"],\n    type=\"drug_interaction\",\n    source=\"clinical_decision_support_v3\",\n    confidence=0.92,\n)\n\n# Bulk \u2014 all edges inside inherit source and confidence\nwith hb.context(source=\"schema_analysis\", confidence=0.9):\n    hb.edge([\"a\", \"b\"], type=\"fk\")\n    hb.edge([\"b\", \"c\"], type=\"fk\")\n\n# Query by provenance\nhb.edges(source=\"clinical_decision_support_v3\")\nhb.edges(min_confidence=0.9)\n\n# Overview of all sources\nhb.sources()\n# [{\"source\": \"clinical_decision_support_v3\", \"edge_count\": 1, \"avg_confidence\": 0.92}, ...]\n</code></pre>"},{"location":"getting-started/#file-persistence","title":"File persistence","text":"<pre><code># Data persists across sessions\nwith Hypabase(\"project.db\") as hb:\n    hb.node(\"alice\", type=\"user\")\n    hb.edge([\"alice\", \"task_1\"], type=\"assigned\")\n# Automatically saved and closed\n\n# Reopen later\nwith Hypabase(\"project.db\") as hb:\n    edges = hb.edges(containing=[\"alice\"])  # data is still there\n</code></pre>"},{"location":"getting-started/#namespace-isolation","title":"Namespace isolation","text":"<p>Separate data into independent namespaces within a single database file:</p> <pre><code>hb = Hypabase(\"project.db\")\n\n# Scoped views \u2014 each namespace has its own nodes and edges\ndrugs = hb.database(\"drugs\")\nsessions = hb.database(\"sessions\")\n\ndrugs.node(\"aspirin\", type=\"medication\")\nsessions.node(\"session_1\", type=\"session\")\n\n# List all namespaces\nhb.databases()  # [\"default\", \"drugs\", \"sessions\"]\n</code></pre>"},{"location":"getting-started/#cli-quickstart","title":"CLI quickstart","text":"<pre><code># Initialize a database\nhypabase init\n\n# Add nodes and edges\nhypabase node dr_smith --type doctor\nhypabase edge dr_smith patient_123 aspirin --type treatment --source clinical --confidence 0.95\n\n# Query\nhypabase query --containing patient_123\nhypabase stats\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Concepts \u2014 learn about hypergraphs, provenance, and vertex-set indexing</li> <li>Traversal guide \u2014 neighbors, shortest paths, and multi-hop queries</li> <li>Provenance guide \u2014 context managers, overrides, and source queries</li> <li>CLI Quickstart \u2014 build a knowledge graph from the terminal</li> <li>Examples \u2014 real-world use cases with working code</li> <li>Comparisons \u2014 how Hypabase compares to Neo4j, vector DBs, and Mem0</li> </ul>"},{"location":"comparisons/vs-mem0/","title":"Hypabase vs Mem0","text":""},{"location":"comparisons/vs-mem0/#different-memory-models","title":"Different memory models","text":"<p>Mem0 stores flat facts \u2014 individual key-value memories like \"Alice prefers dark mode\" or \"User works at Acme Corp.\" Each fact stands alone.</p> <p>Hypabase stores structured relationships \u2014 edges connecting two or more entities with provenance. \"Alice works on the quarterly report with the spreadsheet tool\" is one relationship, not three separate facts.</p>"},{"location":"comparisons/vs-mem0/#architectural-differences","title":"Architectural differences","text":""},{"location":"comparisons/vs-mem0/#mem0","title":"Mem0","text":"<p>Mem0 stores each fact as an independent memory entry:</p> <pre><code>mem0.add(\"Alice is assigned to write the quarterly report\", user_id=\"alice\")\nmem0.add(\"Alice uses the spreadsheet tool\", user_id=\"alice\")\nmem0.add(\"The quarterly report is due Q3\", user_id=\"alice\")\n</code></pre>"},{"location":"comparisons/vs-mem0/#hypabase","title":"Hypabase","text":"<p>Hypabase stores facts as connected edges with explicit relationships between entities:</p> <pre><code>with hb.context(source=\"session_1\", confidence=0.9):\n    hb.edge(\n        [\"user_alice\", \"task_write_report\", \"doc_quarterly\"],\n        type=\"assigned\",\n    )\n    hb.edge(\n        [\"user_alice\", \"task_write_report\", \"tool_spreadsheet\"],\n        type=\"uses_tool\",\n    )\n</code></pre> <p>The relationships are explicit. Query them:</p> <pre><code># What tools are used for the report task?\nreport_edges = hb.edges(containing=[\"task_write_report\"], type=\"uses_tool\")\n\n# How are the report and spreadsheet connected?\npaths = hb.paths(\"doc_quarterly\", \"tool_spreadsheet\")\n# doc_quarterly \u2192 user_alice \u2192 tool_spreadsheet\n</code></pre>"},{"location":"comparisons/vs-mem0/#comparison","title":"Comparison","text":"Mem0 Hypabase Memory model Flat facts (key-value) Structured relationships (hyperedges) Relationships Not stored First-class edges connecting N entities Multi-entity facts Fragmented into separate memories Single atomic edge Provenance None Built-in <code>source</code> and <code>confidence</code> Cross-session queries Search by user/text Query by entity, type, source, confidence Path finding Not possible <code>hb.paths(start, end)</code> Storage Cloud API Local SQLite (zero-config) Retrieval Text similarity search Exact structured queries"},{"location":"comparisons/vs-mem0/#when-to-use-mem0-instead","title":"When to use Mem0 instead","text":"<ul> <li>You only need user preference storage without relationships</li> <li>You want managed cloud storage with no local infrastructure</li> <li>Your facts stand alone with no connections between them</li> <li>You need text-based semantic search over memories</li> </ul>"},{"location":"comparisons/vs-mem0/#when-to-use-hypabase-instead","title":"When to use Hypabase instead","text":"<ul> <li>Your agent needs to remember relationships between entities (people, tasks, tools, documents)</li> <li>You need to traverse connections between memories</li> <li>You need provenance \u2014 which session or interaction created each memory</li> <li>You need confidence scores to distinguish certain from inferred memories</li> <li>You want local-first storage without cloud dependencies</li> </ul>"},{"location":"comparisons/vs-mem0/#session-aware-memory","title":"Session-aware memory","text":"<p>Hypabase tracks which session created each memory using provenance context blocks. See the Agent Memory example for a complete multi-session walkthrough.</p>"},{"location":"comparisons/vs-neo4j/","title":"Hypabase vs Neo4j","text":""},{"location":"comparisons/vs-neo4j/#the-core-difference","title":"The core difference","text":"<p>Neo4j is a property graph database. Every edge connects exactly two nodes. When your data has relationships between 3+ entities, Neo4j forces you to decompose them.</p> <p>Hypabase is a hypergraph database. A single edge connects any number of nodes.</p>"},{"location":"comparisons/vs-neo4j/#modeling-n-ary-relationships","title":"Modeling n-ary relationships","text":"<p>The fact: \"Dr. Smith treated Patient 123 with Aspirin for Headache at Mercy Hospital\"</p>"},{"location":"comparisons/vs-neo4j/#neo4j","title":"Neo4j","text":"<p>Neo4j edges connect exactly two nodes. To model a 5-entity relationship, you use an intermediate node (reification pattern):</p> <pre><code>CREATE (t:Treatment)\nCREATE (dr_smith)-[:TREATS]-&gt;(t)\nCREATE (t)-[:PATIENT]-&gt;(patient_123)\nCREATE (t)-[:MEDICATION]-&gt;(aspirin)\nCREATE (t)-[:CONDITION]-&gt;(headache)\nCREATE (t)-[:LOCATION]-&gt;(mercy_hospital)\n</code></pre>"},{"location":"comparisons/vs-neo4j/#hypabase","title":"Hypabase","text":"<p>Hypabase edges connect any number of nodes directly:</p> <pre><code>hb.edge(\n    [\"dr_smith\", \"patient_123\", \"aspirin\", \"headache\", \"mercy_hospital\"],\n    type=\"treatment\",\n    source=\"clinical_records\",\n    confidence=0.95,\n)\n</code></pre>"},{"location":"comparisons/vs-neo4j/#comparison","title":"Comparison","text":"Neo4j Hypabase Edge model Binary (2 nodes per edge) N-ary (2+ nodes per edge) N-ary relationships Reification pattern (intermediate nodes) Native hyperedges Provenance Custom properties (no standard) Built-in <code>source</code> and <code>confidence</code> Query language Cypher Python SDK (no query language) Setup Server process, Docker, or Aura cloud <code>uv add hypabase</code> \u2014 zero config Storage Custom binary format SQLite (local-first) Vertex-set lookup Multi-hop traversal O(1) hash index Visualization Neo4j Browser, Bloom None (library, not platform) Community Large, established New"},{"location":"comparisons/vs-neo4j/#when-to-use-neo4j-instead","title":"When to use Neo4j instead","text":"<ul> <li>You only have pairwise relationships</li> <li>You need Cypher's query expressiveness for complex graph patterns</li> <li>You need a managed cloud service (Neo4j Aura)</li> <li>You need built-in visualization (Neo4j Browser, Bloom)</li> <li>Your team already knows Neo4j and Cypher</li> </ul>"},{"location":"comparisons/vs-neo4j/#when-to-use-hypabase-instead","title":"When to use Hypabase instead","text":"<ul> <li>Your relationships connect 3+ entities</li> <li>You need provenance tracking (source, confidence) as part of the data model</li> <li>You want zero-config local-first storage</li> <li>You're building for AI agents or LLM pipelines (SDK-only API, no query language)</li> <li>You want <code>uv add</code> and go, not a server process</li> </ul>"},{"location":"comparisons/vs-neo4j/#code-comparison-patient-lookup","title":"Code comparison: patient lookup","text":""},{"location":"comparisons/vs-neo4j/#neo4j_1","title":"Neo4j","text":"<pre><code>MATCH (p:Patient {id: 'patient_123'})-[:PATIENT]-(t:Treatment)\nMATCH (t)-[:TREATS]-(d:Doctor)\nMATCH (t)-[:MEDICATION]-(m:Medication)\nMATCH (t)-[:CONDITION]-(c:Condition)\nRETURN d, m, c\n</code></pre>"},{"location":"comparisons/vs-neo4j/#hypabase_1","title":"Hypabase","text":"<pre><code>edges = hb.edges(containing=[\"patient_123\"], type=\"treatment\")\n# Each edge contains all connected entities directly\n</code></pre>"},{"location":"comparisons/vs-vector-dbs/","title":"Hypabase vs Vector Databases","text":""},{"location":"comparisons/vs-vector-dbs/#different-tools-different-jobs","title":"Different tools, different jobs","text":"<p>Vector databases (Pinecone, Qdrant, Weaviate, ChromaDB, pgvector) store embeddings and find matches. They answer \"what resembles X?\"</p> <p>Hypabase stores relationships and finds connections. It answers \"what's connected to X, through which relationships, with what provenance?\"</p> <p>Vector databases and Hypabase complement each other.</p>"},{"location":"comparisons/vs-vector-dbs/#what-vector-databases-do","title":"What vector databases do","text":"<p>Vector databases store embeddings and retrieve by similarity. They excel at semantic search (\"find documents about GDPR\"), fuzzy natural language queries, and ranking by embedding distance.</p>"},{"location":"comparisons/vs-vector-dbs/#what-hypabase-does","title":"What Hypabase does","text":"<p>Hypabase stores explicit relationships between entities and retrieves by structure. It provides multi-entity edges, multi-hop traversal, provenance tracking (<code>source</code> and <code>confidence</code>), and exact vertex-set lookup.</p>"},{"location":"comparisons/vs-vector-dbs/#comparison","title":"Comparison","text":"Capability Vector DB Hypabase Semantic similarity search Yes No Structured relationships No Yes Multi-hop traversal No Yes N-ary facts (3+ entities) No Yes Provenance tracking No Yes Fuzzy natural language queries Yes No Confidence-based filtering No Yes"},{"location":"comparisons/vs-vector-dbs/#the-hybrid-pattern","title":"The hybrid pattern","text":"<p>For RAG and knowledge systems, a strong architecture combines both:</p> <ol> <li>Vector DB for initial semantic retrieval \u2014 find relevant documents/chunks</li> <li>Hypabase for structured relationship queries \u2014 find connected entities with provenance</li> <li>Combine both contexts for the LLM</li> </ol> <p>See the Hybrid Vector Pattern for a complete implementation with code.</p>"},{"location":"comparisons/vs-vector-dbs/#related-research","title":"Related research","text":"<p>HyperGraphRAG (NeurIPS 2025) studied n-ary retrieval vs binary graph retrieval across medicine, agriculture, computer science, and law.</p>"},{"location":"examples/agent-memory/","title":"Agent Memory","text":"<p>Use Hypabase as persistent, structured memory for AI agents across sessions, with session-tagged provenance.</p>"},{"location":"examples/agent-memory/#multi-session-persistence","title":"Multi-session persistence","text":"<p>Hypabase persists to SQLite. An agent can write memory in one session and read it in the next:</p> <pre><code>from hypabase import Hypabase\n\n# --- Session 1: Agent records task context ---\nwith Hypabase(\"agent_memory.db\") as hb:\n    with hb.context(source=\"session_1\", confidence=0.9):\n        hb.node(\"user_alice\", type=\"user\")\n        hb.node(\"task_write_report\", type=\"task\")\n        hb.node(\"doc_quarterly\", type=\"document\")\n        hb.edge(\n            [\"user_alice\", \"task_write_report\", \"doc_quarterly\"],\n            type=\"assigned\",\n        )\n</code></pre> <pre><code># --- Session 2: Agent reopens, queries, adds new context ---\nwith Hypabase(\"agent_memory.db\") as hb:\n    # Session 1 data is still there\n    alice_edges = hb.edges(containing=[\"user_alice\"])\n    # Returns the \"assigned\" edge from session 1\n\n    with hb.context(source=\"session_2\", confidence=0.85):\n        hb.node(\"tool_spreadsheet\", type=\"tool\")\n        hb.edge(\n            [\"user_alice\", \"task_write_report\", \"tool_spreadsheet\"],\n            type=\"uses_tool\",\n        )\n</code></pre> <pre><code># --- Session 3: Agent queries across all sessions ---\nwith Hypabase(\"agent_memory.db\") as hb:\n    # All data from all sessions\n    assert len(hb.nodes()) == 4\n    assert len(hb.edges()) == 2\n\n    # Cross-session path discovery\n    paths = hb.paths(\"doc_quarterly\", \"tool_spreadsheet\")\n    # doc_quarterly \u2192 user_alice \u2192 tool_spreadsheet (across sessions)\n\n    # Track which session contributed what\n    sources = hb.sources()\n    # [\n    #     {\"source\": \"session_1\", \"edge_count\": 1, \"avg_confidence\": 0.9},\n    #     {\"source\": \"session_2\", \"edge_count\": 1, \"avg_confidence\": 0.85},\n    # ]\n</code></pre>"},{"location":"examples/agent-memory/#key-patterns","title":"Key patterns","text":""},{"location":"examples/agent-memory/#session-tracking-via-provenance","title":"Session tracking via provenance","text":"<p>Use <code>source</code> to track which session or agent interaction created each memory:</p> <pre><code>with hb.context(source=f\"session_{session_id}\", confidence=0.9):\n    # All memories in this block are tagged with the session\n    hb.edge([user, task, resource], type=\"context\")\n</code></pre>"},{"location":"examples/agent-memory/#confidence-decay","title":"Confidence decay","text":"<p>Lower confidence for older or uncertain memories:</p> <pre><code># Fresh interaction \u2014 high confidence\nwith hb.context(source=\"session_current\", confidence=0.95):\n    hb.edge([\"user\", \"preference_dark_mode\"], type=\"prefers\")\n\n# Inferred from past behavior \u2014 lower confidence\nwith hb.context(source=\"inference_engine\", confidence=0.6):\n    hb.edge([\"user\", \"preference_vim\"], type=\"likely_prefers\")\n</code></pre>"},{"location":"examples/agent-memory/#context-retrieval","title":"Context retrieval","text":"<p>When the agent needs to recall context about an entity:</p> <pre><code>def get_agent_context(hb, entity_id, min_confidence=0.7):\n    \"\"\"Retrieve all high-confidence memories about an entity.\"\"\"\n    edges = hb.edges(\n        containing=[entity_id],\n        min_confidence=min_confidence,\n    )\n    neighbors = hb.neighbors(entity_id)\n    return {\n        \"relationships\": edges,\n        \"connected_entities\": neighbors,\n    }\n</code></pre>"},{"location":"examples/agent-memory/#decision-traces","title":"Decision traces","text":"<p>Record why the agent made a decision:</p> <pre><code>with hb.context(source=\"planning_step_3\", confidence=0.88):\n    hb.edge(\n        [\"decision_use_react\", \"requirement_speed\", \"constraint_team_skill\"],\n        type=\"decision_trace\",\n        properties={\"reasoning\": \"React chosen due to team familiarity\"},\n    )\n</code></pre> <p>Later, the agent (or a human) can audit the decision:</p> <pre><code>decisions = hb.edges(type=\"decision_trace\")\nfor d in decisions:\n    print(f\"Decision involved: {d.node_ids}\")\n    print(f\"Source: {d.source}, Confidence: {d.confidence}\")\n    print(f\"Reasoning: {d.properties.get('reasoning')}\")\n</code></pre>"},{"location":"examples/hybrid-vector/","title":"Hybrid Vector Pattern","text":"<p>Combine Hypabase (structured relationships) with a vector database (semantic similarity).</p>"},{"location":"examples/hybrid-vector/#when-to-use-this-pattern","title":"When to use this pattern","text":"<ul> <li>You need both semantic search (\"find documents about GDPR\") and structured queries (\"which entities connect to regulation_gdpr?\")</li> <li>Your RAG pipeline needs to retrieve related entities, not only similar text chunks</li> <li>You want provenance-tracked relationships alongside vector similarity scores</li> </ul>"},{"location":"examples/hybrid-vector/#architecture","title":"Architecture","text":"<pre><code>Query \u2192 Vector DB (semantic retrieval) \u2192 entity IDs\n     \u2192 Hypabase (structured relationships) \u2192 connected entities\n     \u2192 Combine both \u2192 LLM context\n</code></pre> <p>The vector database finds what's relevant. Hypabase finds what's connected.</p>"},{"location":"examples/hybrid-vector/#example-legal-document-analysis","title":"Example: Legal document analysis","text":""},{"location":"examples/hybrid-vector/#step-1-store-extractions-in-both-systems","title":"Step 1: Store extractions in both systems","text":"<pre><code>from hypabase import Hypabase\n\nhb = Hypabase(\"legal_kg.db\")\n\n# After LLM extracts entities and relationships from documents:\nwith hb.context(source=\"doc_gdpr_analysis\", confidence=0.9):\n    hb.edge(\n        [\"regulation_gdpr\", \"company_techcorp\", \"violation_data_breach\"],\n        type=\"enforcement_action\",\n    )\n    hb.edge(\n        [\"regulation_gdpr\", \"right_to_erasure\", \"article_17\"],\n        type=\"defines\",\n    )\n    hb.edge(\n        [\"company_techcorp\", \"fine_20m\", \"year_2024\"],\n        type=\"penalty\",\n    )\n\n# Meanwhile, store document chunks in your vector DB:\n# vector_db.upsert(chunks, embeddings)\n</code></pre>"},{"location":"examples/hybrid-vector/#step-2-hybrid-retrieval","title":"Step 2: Hybrid retrieval","text":"<pre><code>def hybrid_retrieve(query_text, hb, vector_db, min_confidence=0.7):\n    \"\"\"Combine vector search with structured graph queries.\"\"\"\n\n    # 1. Vector search for semantic retrieval\n    similar_docs = vector_db.search(query_text, top_k=10)\n    doc_entity_ids = extract_entity_ids(similar_docs)\n\n    # 2. Hypabase for structured multi-entity queries\n    edges = hb.edges(\n        containing=doc_entity_ids,\n        min_confidence=min_confidence,\n    )\n\n    # 3. Expand context with graph neighbors\n    all_entities = set()\n    for e in edges:\n        all_entities.update(e.node_ids)\n\n    neighbor_edges = []\n    for entity in all_entities:\n        neighbor_edges.extend(\n            hb.edges_of_node(entity, edge_types=[\"defines\", \"enforcement_action\"])\n        )\n\n    return {\n        \"vector_results\": similar_docs,\n        \"graph_relationships\": edges,\n        \"expanded_context\": neighbor_edges,\n    }\n</code></pre>"},{"location":"examples/hybrid-vector/#step-3-build-llm-context","title":"Step 3: Build LLM context","text":"<pre><code>def build_context(retrieval_results):\n    \"\"\"Format hybrid results for LLM consumption.\"\"\"\n    parts = []\n\n    # Structured relationships\n    parts.append(\"Known relationships:\")\n    for e in retrieval_results[\"graph_relationships\"]:\n        parts.append(\n            f\"  {e.type}: {' + '.join(e.node_ids)} \"\n            f\"(confidence={e.confidence})\"\n        )\n\n    # Relevant text passages\n    parts.append(\"\\nRelevant passages:\")\n    for doc in retrieval_results[\"vector_results\"]:\n        parts.append(f\"  {doc['text'][:200]}...\")\n\n    return \"\\n\".join(parts)\n</code></pre>"},{"location":"examples/hybrid-vector/#what-each-system-provides","title":"What each system provides","text":"<p>Vector database: semantic similarity search, fuzzy natural language queries, embedding-based ranking.</p> <p>Hypabase: structured relationship queries, multi-hop traversal, provenance filtering, n-ary facts.</p> <p>The hybrid pattern combines both \u2014 semantic retrieval to find relevant entities, then structured queries to expand context with connected relationships and provenance.</p>"},{"location":"examples/hybrid-vector/#compatible-vector-databases","title":"Compatible vector databases","text":"<p>Any vector database works with this pattern:</p> <ul> <li>ChromaDB \u2014 local-first, Python-native (good match for Hypabase's local-first model)</li> <li>Qdrant \u2014 high-performance, supports filtering</li> <li>Weaviate \u2014 hybrid search built-in</li> <li>Pinecone \u2014 managed cloud service</li> <li>pgvector \u2014 PostgreSQL extension</li> </ul>"},{"location":"examples/medical-kg/","title":"Medical Knowledge Graph","text":"<p>Build a clinical knowledge graph where treatment events are single edges.</p> <p>A treatment event connects a doctor, patient, medication, condition, and location. This example builds a graph of such events and shows query patterns.</p>"},{"location":"examples/medical-kg/#setup","title":"Setup","text":"<pre><code>from hypabase import Hypabase\n\nhb = Hypabase(\"clinical.db\")\n</code></pre>"},{"location":"examples/medical-kg/#build-the-graph","title":"Build the graph","text":"<pre><code># Create typed nodes\nhb.node(\"dr_smith\", type=\"doctor\")\nhb.node(\"dr_jones\", type=\"doctor\")\nhb.node(\"patient_a\", type=\"patient\")\nhb.node(\"patient_b\", type=\"patient\")\nhb.node(\"aspirin\", type=\"medication\")\nhb.node(\"ibuprofen\", type=\"medication\")\nhb.node(\"headache\", type=\"condition\")\nhb.node(\"fever\", type=\"condition\")\nhb.node(\"mercy_hospital\", type=\"hospital\")\n\n# Record treatments with provenance\nwith hb.context(source=\"clinical_records\", confidence=0.95):\n    hb.edge(\n        [\"dr_smith\", \"patient_a\", \"aspirin\", \"headache\", \"mercy_hospital\"],\n        type=\"treatment\",\n    )\n    hb.edge(\n        [\"dr_jones\", \"patient_b\", \"ibuprofen\", \"fever\"],\n        type=\"treatment\",\n    )\n\n# Record diagnosis from a different source\nwith hb.context(source=\"lab_results\", confidence=0.88):\n    hb.edge(\n        [\"dr_smith\", \"patient_a\", \"headache\"],\n        type=\"diagnosis\",\n    )\n</code></pre>"},{"location":"examples/medical-kg/#query-patterns","title":"Query patterns","text":""},{"location":"examples/medical-kg/#patient-lookup","title":"Patient lookup","text":"<p>Find all edges involving a patient:</p> <pre><code>edges = hb.edges(containing=[\"patient_a\"])\n# Returns: treatment edge + diagnosis edge\n</code></pre>"},{"location":"examples/medical-kg/#provenance-filtering","title":"Provenance filtering","text":"<p>Retrieve only high-confidence relationships:</p> <pre><code>high_conf = hb.edges(min_confidence=0.9)\n# Returns: both treatment edges (0.95), excludes diagnosis (0.88)\n</code></pre>"},{"location":"examples/medical-kg/#path-finding","title":"Path finding","text":"<p>Discover how entities connect:</p> <pre><code>paths = hb.paths(\"dr_smith\", \"mercy_hospital\")\n# [[\"dr_smith\", \"patient_a\", \"mercy_hospital\"], ...]\n</code></pre>"},{"location":"examples/medical-kg/#n-ary-preservation-check","title":"N-ary preservation check","text":"<p>Verify that a single edge stores the 5-entity treatment:</p> <pre><code>treatments = hb.edges(type=\"treatment\")\nfive_node = [e for e in treatments if len(e.node_ids) == 5]\nassert len(five_node) == 1\nassert set(five_node[0].node_ids) == {\n    \"dr_smith\", \"patient_a\", \"aspirin\", \"headache\", \"mercy_hospital\"\n}\n</code></pre>"},{"location":"examples/medical-kg/#source-overview","title":"Source overview","text":"<p>Audit which sources contributed what:</p> <pre><code>sources = hb.sources()\n# [\n#     {\"source\": \"clinical_records\", \"edge_count\": 2, \"avg_confidence\": 0.95},\n#     {\"source\": \"lab_results\", \"edge_count\": 1, \"avg_confidence\": 0.88},\n# ]\n</code></pre>"},{"location":"examples/rag-extraction/","title":"RAG Extraction Pipeline","text":"<p>Build a knowledge graph from document extractions, storing entities and relationships with per-source confidence scores.</p>"},{"location":"examples/rag-extraction/#setup","title":"Setup","text":"<pre><code>from hypabase import Hypabase\n\nhb = Hypabase(\"knowledge.db\")\n</code></pre>"},{"location":"examples/rag-extraction/#extract-and-store","title":"Extract and store","text":"<p>Simulate extracting facts from three documents with different confidence levels:</p> <pre><code># High-quality academic paper\nwith hb.context(source=\"doc_arxiv_2401\", confidence=0.92):\n    hb.edge([\"transformer\", \"attention\", \"nlp\"], type=\"concept_link\")\n    hb.edge([\"bert\", \"transformer\", \"pretraining\"], type=\"builds_on\")\n\n# Blog post \u2014 lower confidence\nwith hb.context(source=\"doc_blog_post\", confidence=0.75):\n    hb.edge([\"transformer\", \"gpu\", \"training\"], type=\"requires\")\n    hb.edge([\"attention\", \"memory\", \"scaling\"], type=\"tradeoff\")\n\n# Textbook with moderate confidence\nwith hb.context(source=\"doc_textbook_ch5\", confidence=0.5):\n    hb.edge([\"rnn\", \"lstm\", \"attention\"], type=\"evolution\")\n</code></pre> <p>Each extraction batch gets its own source and confidence. The provenance context manager handles this cleanly.</p>"},{"location":"examples/rag-extraction/#query-patterns","title":"Query patterns","text":""},{"location":"examples/rag-extraction/#entity-retrieval","title":"Entity retrieval","text":"<p>Find all relationships involving a concept:</p> <pre><code>edges = hb.edges(containing=[\"transformer\"])\n# Returns 3 edges: concept_link, builds_on, requires\n</code></pre>"},{"location":"examples/rag-extraction/#source-filtering","title":"Source filtering","text":"<p>Retrieve facts from a specific document:</p> <pre><code>edges = hb.edges(source=\"doc_arxiv_2401\")\n# Returns 2 edges from the arxiv paper\n</code></pre>"},{"location":"examples/rag-extraction/#confidence-based-retrieval","title":"Confidence-based retrieval","text":"<p>Only include high-quality extractions in your RAG context:</p> <pre><code>high_quality = hb.edges(min_confidence=0.8)\n# Returns 2 edges (arxiv paper), excludes blog post and textbook\n</code></pre>"},{"location":"examples/rag-extraction/#multi-hop-discovery","title":"Multi-hop discovery","text":"<p>Find paths between concepts across documents:</p> <pre><code>paths = hb.paths(\"bert\", \"nlp\")\n# bert \u2192 transformer \u2192 nlp (across two extraction sources)\n</code></pre>"},{"location":"examples/rag-extraction/#n-ary-fact-preservation","title":"N-ary fact preservation","text":"<p>A single edge stores the 3-way concept link:</p> <pre><code>concept_links = hb.edges(type=\"concept_link\")\nassert len(concept_links[0].node_ids) == 3\n# [\"transformer\", \"attention\", \"nlp\"] \u2014 not three separate pairs\n</code></pre>"},{"location":"examples/rag-extraction/#integration-with-llm-extraction","title":"Integration with LLM extraction","text":"<p>A typical pipeline:</p> <pre><code>import json\n\ndef extract_and_store(document_id, text, hb):\n    \"\"\"Extract facts from text using an LLM and store in Hypabase.\"\"\"\n    # Your LLM extraction logic here\n    # Returns: [{\"entities\": [...], \"type\": \"...\", \"confidence\": ...}, ...]\n    extractions = llm_extract(text)\n\n    with hb.context(source=document_id, confidence=0.85):\n        with hb.batch():  # Single save for all extractions\n            for fact in extractions:\n                hb.edge(\n                    fact[\"entities\"],\n                    type=fact[\"type\"],\n                    confidence=fact.get(\"confidence\"),  # Override if LLM provides per-fact score\n                )\n</code></pre>"},{"location":"examples/rag-extraction/#rag-retrieval-function","title":"RAG retrieval function","text":"<pre><code>def retrieve_context(query_entities, hb, min_confidence=0.7):\n    \"\"\"Retrieve structured relationships for RAG context.\"\"\"\n    edges = hb.edges(\n        containing=query_entities,\n        min_confidence=min_confidence,\n    )\n    # Format for LLM context\n    facts = []\n    for e in edges:\n        facts.append(\n            f\"{e.type}: {' + '.join(e.node_ids)} \"\n            f\"(source={e.source}, confidence={e.confidence})\"\n        )\n    return \"\\n\".join(facts)\n</code></pre> <p>This gives your LLM structured, provenance-tracked relationships as context.</p>"},{"location":"guides/batch-operations/","title":"Batch Operations","text":""},{"location":"guides/batch-operations/#batch-persistence","title":"Batch persistence","text":"<p>By default, Hypabase auto-saves to SQLite after every mutation. For bulk inserts, use <code>batch()</code> to defer persistence until the block exits:</p> <pre><code>with hb.batch():\n    for i in range(1000):\n        hb.node(f\"entity_{i}\", type=\"item\")\n        hb.edge([f\"entity_{i}\", \"catalog\"], type=\"belongs_to\")\n# Single save at the end, not 2000 saves\n</code></pre> <p>Note</p> <p><code>batch()</code> provides batched persistence, not transaction rollback. If an exception occurs mid-batch, partial in-memory changes remain and persist when the batch exits.</p>"},{"location":"guides/batch-operations/#nested-batches","title":"Nested batches","text":"<p>Batches can nest. Only the outermost batch triggers a save:</p> <pre><code>with hb.batch():\n    hb.node(\"a\", type=\"x\")\n    with hb.batch():\n        hb.node(\"b\", type=\"x\")\n        hb.node(\"c\", type=\"x\")\n    # No save yet \u2014 inner batch exited but outer batch is still open\n    hb.node(\"d\", type=\"x\")\n# Save happens here \u2014 outermost batch exits\n</code></pre>"},{"location":"guides/batch-operations/#upsert-by-vertex-set","title":"Upsert by vertex set","text":"<p><code>upsert_edge_by_vertex_set()</code> finds an existing edge by its exact set of nodes, or creates a new one. This is useful for idempotent ingestion:</p> <pre><code># First call creates the edge\nedge = hb.upsert_edge_by_vertex_set(\n    {\"dr_smith\", \"patient_123\", \"aspirin\"},\n    edge_type=\"treatment\",\n    properties={\"date\": \"2025-01-15\"},\n    source=\"clinical_records\",\n    confidence=0.95,\n)\n\n# Second call finds the existing edge (same vertex set)\nedge = hb.upsert_edge_by_vertex_set(\n    {\"dr_smith\", \"patient_123\", \"aspirin\"},\n    edge_type=\"treatment\",\n    properties={\"date\": \"2025-01-16\"},  # updates properties\n)\n</code></pre>"},{"location":"guides/batch-operations/#custom-merge-function","title":"Custom merge function","text":"<p>Pass a <code>merge_fn</code> to control how the upsert merges properties:</p> <pre><code>def merge_latest(existing_props, new_props):\n    return {**existing_props, **new_props}\n\nhb.upsert_edge_by_vertex_set(\n    {\"a\", \"b\"},\n    edge_type=\"link\",\n    properties={\"count\": 2},\n    merge_fn=merge_latest,\n)\n</code></pre>"},{"location":"guides/batch-operations/#cascade-delete","title":"Cascade delete","text":"<p>Delete a node and all its incident edges in one call:</p> <pre><code>node_deleted, edges_deleted = hb.delete_node_cascade(\"patient_123\")\n# node_deleted: True if the node existed\n# edges_deleted: number of edges removed\n</code></pre> <p>Compare with <code>delete_node()</code>, which only removes the node itself:</p> <pre><code>hb.delete_node(\"patient_123\")  # Removes the node, edges remain (with dangling references)\n</code></pre>"},{"location":"guides/batch-operations/#bulk-ingestion-pattern","title":"Bulk ingestion pattern","text":"<p>Combine <code>batch()</code> and <code>context()</code> for efficient bulk loading:</p> <pre><code>with hb.batch():\n    with hb.context(source=\"data_import_v2\", confidence=0.9):\n        for record in records:\n            hb.edge(\n                record[\"entities\"],\n                type=record[\"relation_type\"],\n                properties=record.get(\"metadata\", {}),\n            )\n</code></pre> <p>This gives you:</p> <ul> <li>Single disk write at the end (<code>batch</code>)</li> <li>Consistent provenance across all edges (<code>context</code>)</li> <li>Auto-created nodes for any new entity IDs</li> </ul>"},{"location":"guides/cli/","title":"CLI Quickstart","text":"<p>Build a knowledge graph from the command line \u2014 no Python needed.</p>"},{"location":"guides/cli/#install","title":"Install","text":"<pre><code>uv add \"hypabase[cli]\"\n</code></pre>"},{"location":"guides/cli/#build-a-graph-in-five-commands","title":"Build a graph in five commands","text":"<p>Start with an empty database and populate it step by step:</p> <pre><code># 1. Initialize the database\nhypabase init\n# Initialized Hypabase database at hypabase.db\n\n# 2. Create nodes\nhypabase node dr_smith --type doctor\nhypabase node patient_123 --type patient\nhypabase node aspirin --type medication\n\n# 3. Create a hyperedge connecting all three\nhypabase edge dr_smith patient_123 aspirin --type treatment --source clinical --confidence 0.95\n\n# 4. Query edges containing a node\nhypabase query --containing patient_123\n\n# 5. Check database stats\nhypabase stats\n# Nodes: 3  Edges: 1\n</code></pre>"},{"location":"guides/cli/#work-with-a-specific-database-file","title":"Work with a specific database file","text":"<p>All commands default to <code>hypabase.db</code>. Use <code>--db</code> to target a different file:</p> <pre><code>hypabase --db research.db init\nhypabase --db research.db node paper_1 --type paper\nhypabase --db research.db edge paper_1 transformer bert --type builds_on\nhypabase --db research.db stats\n</code></pre>"},{"location":"guides/cli/#query-with-filters","title":"Query with filters","text":"<p>Combine flags to narrow results:</p> <pre><code># Edges containing both nodes\nhypabase query --containing patient_123 --containing aspirin --match-all\n\n# Edges of a specific type\nhypabase query --type treatment\n</code></pre>"},{"location":"guides/cli/#export-and-import","title":"Export and import","text":"<p>Move hypergraphs between databases using HIF (Hypergraph Interchange Format):</p> <pre><code>hypabase export-hif backup.json\nhypabase --db copy.db import-hif backup.json\n</code></pre>"},{"location":"guides/cli/#validate-consistency","title":"Validate consistency","text":"<p>Check that the database has no orphaned references:</p> <pre><code>hypabase validate\n# Hypergraph is valid.\n</code></pre> <p>See the CLI Reference for all commands, flags, and options.</p>"},{"location":"guides/hif/","title":"HIF Import/Export","text":"<p>HIF (Hypergraph Interchange Format) is a JSON format for representing hypergraphs. Hypabase supports full round-trip import and export.</p>"},{"location":"guides/hif/#export","title":"Export","text":""},{"location":"guides/hif/#python-api","title":"Python API","text":"<pre><code>hb = Hypabase(\"myproject.db\")\nhif_data = hb.to_hif()\n\n# Write to file\nimport json\nwith open(\"export.json\", \"w\") as f:\n    json.dump(hif_data, f, indent=2)\n</code></pre>"},{"location":"guides/hif/#cli","title":"CLI","text":"<pre><code>hypabase export-hif export.json\n</code></pre>"},{"location":"guides/hif/#import","title":"Import","text":""},{"location":"guides/hif/#python-api_1","title":"Python API","text":"<pre><code>import json\n\nwith open(\"export.json\") as f:\n    hif_data = json.load(f)\n\nhb = Hypabase.from_hif(hif_data)\n\n# The imported graph is in-memory. To persist:\n# Option 1: Work with it in-memory\nedges = hb.edges()\n\n# Option 2: Save to a new database\n# (use the storage layer directly for this)\n</code></pre>"},{"location":"guides/hif/#cli_1","title":"CLI","text":"<pre><code>hypabase --db imported.db import-hif export.json\n</code></pre>"},{"location":"guides/hif/#hif-format-structure","title":"HIF format structure","text":"<p>The HIF JSON contains nodes and edges with their full metadata:</p> <pre><code>{\n  \"nodes\": [\n    {\n      \"id\": \"dr_smith\",\n      \"type\": \"doctor\",\n      \"properties\": {\"specialty\": \"neurology\"}\n    }\n  ],\n  \"edges\": [\n    {\n      \"id\": \"edge_uuid\",\n      \"type\": \"treatment\",\n      \"incidences\": [\n        {\"node_id\": \"dr_smith\", \"direction\": null},\n        {\"node_id\": \"patient_123\", \"direction\": null}\n      ],\n      \"source\": \"clinical_records\",\n      \"confidence\": 0.95,\n      \"properties\": {}\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/hif/#use-cases","title":"Use cases","text":"<ul> <li>Backup and restore \u2014 export a database, archive it, import it later</li> <li>Migration \u2014 move data between Hypabase instances</li> <li>Sharing \u2014 exchange hypergraph datasets with collaborators</li> <li>Testing \u2014 create fixtures from HIF files</li> <li>Interop \u2014 bridge to other tools that support HIF</li> </ul>"},{"location":"guides/mcp/","title":"MCP Server","text":"<p>Hypabase ships an MCP server that exposes the full hypergraph API as tools for AI agents. Any MCP-compatible client \u2014 Claude Code, Claude Desktop, Cursor, Windsurf, or custom agents \u2014 can create nodes, build hyperedges, query the graph, and traverse paths.</p>"},{"location":"guides/mcp/#installation","title":"Installation","text":"<p>Install Hypabase with the <code>mcp</code> extra:</p> <pre><code>uv add \"hypabase[mcp]\"\n</code></pre>"},{"location":"guides/mcp/#starting-the-server","title":"Starting the server","text":"<p>The MCP server runs over stdio (JSON-RPC):</p> <pre><code>hypabase-mcp\n</code></pre> <p>By default it opens <code>hypabase.db</code> in the current directory. Set <code>HYPABASE_DB_PATH</code> to use a different file:</p> <pre><code>HYPABASE_DB_PATH=/path/to/knowledge.db hypabase-mcp\n</code></pre>"},{"location":"guides/mcp/#client-configuration","title":"Client configuration","text":""},{"location":"guides/mcp/#claude-desktop","title":"Claude Desktop","text":"<p>Add to your <code>claude_desktop_config.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"hypabase\": {\n      \"command\": \"hypabase-mcp\",\n      \"env\": {\n        \"HYPABASE_DB_PATH\": \"/path/to/knowledge.db\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/mcp/#claude-code","title":"Claude Code","text":"<p>Add to <code>.mcp.json</code> in your project root (shared with the team):</p> <pre><code>{\n  \"mcpServers\": {\n    \"hypabase\": {\n      \"type\": \"stdio\",\n      \"command\": \"hypabase-mcp\",\n      \"env\": {\n        \"HYPABASE_DB_PATH\": \"/path/to/knowledge.db\"\n      }\n    }\n  }\n}\n</code></pre> <p>Or add via the CLI:</p> <pre><code>claude mcp add --transport stdio --env HYPABASE_DB_PATH=/path/to/knowledge.db hypabase -- hypabase-mcp\n</code></pre>"},{"location":"guides/mcp/#cursor","title":"Cursor","text":"<p>Add to <code>.cursor/mcp.json</code> in your project root:</p> <pre><code>{\n  \"mcpServers\": {\n    \"hypabase\": {\n      \"command\": \"hypabase-mcp\",\n      \"env\": {\n        \"HYPABASE_DB_PATH\": \"/path/to/knowledge.db\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/mcp/#windsurf","title":"Windsurf","text":"<p>Add to your Windsurf MCP configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"hypabase\": {\n      \"command\": \"hypabase-mcp\",\n      \"env\": {\n        \"HYPABASE_DB_PATH\": \"/path/to/knowledge.db\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/mcp/#tools","title":"Tools","text":"<p>The server exposes 14 tools across three categories.</p>"},{"location":"guides/mcp/#node-tools-4","title":"Node tools (4)","text":"Tool Description <code>create_node</code> Create or update a node in the hypergraph <code>get_node</code> Get a node by its ID <code>search_nodes</code> Search for nodes by type and/or property values <code>delete_node</code> Delete a node and all its connected edges (cascade)"},{"location":"guides/mcp/#edge-tools-7","title":"Edge tools (7)","text":"Tool Description <code>create_edge</code> Create a hyperedge connecting two or more nodes <code>batch_create_edges</code> Create hyperedges in a single batch <code>get_edge</code> Get an edge by its ID <code>search_edges</code> Search for edges by contained nodes, type, provenance, or properties <code>upsert_edge</code> Create or update an edge by its exact set of nodes (idempotent) <code>delete_edge</code> Delete an edge by its ID <code>lookup_edges_by_nodes</code> O(1) lookup: find edges with exactly this set of nodes"},{"location":"guides/mcp/#traversal-analysis-tools-3","title":"Traversal &amp; analysis tools (3)","text":"Tool Description <code>get_neighbors</code> Find all nodes connected to a given node via shared edges <code>find_paths</code> Find paths between two nodes through hyperedges (BFS) <code>get_stats</code> Get database statistics, provenance sources, and available namespaces"},{"location":"guides/mcp/#resources","title":"Resources","text":"<p>The server also exposes 2 MCP resources:</p> Resource URI Description <code>hypabase://schema</code> Hypabase data model reference \u2014 nodes, edges, provenance, namespaces <code>hypabase://stats</code> Live database statistics and namespace listing"},{"location":"guides/mcp/#namespace-support","title":"Namespace support","text":"<p>Every tool accepts an optional <code>database</code> parameter to scope operations to a namespace. This lets an agent maintain isolated graphs (e.g., separate knowledge domains) within a single database file:</p> <pre><code>create_node(id=\"aspirin\", type=\"drug\", database=\"pharma\")\ncreate_node(id=\"session_1\", type=\"session\", database=\"agent_memory\")\n</code></pre>"},{"location":"guides/mcp/#example-workflow","title":"Example workflow","text":"<p>A typical agent session:</p> <ol> <li>Create nodes for entities discovered during conversation</li> <li>Create edges to record relationships between entities (with provenance)</li> <li>Search edges to recall what the agent knows about a topic</li> <li>Find paths to discover indirect connections</li> <li>Get stats to understand the current state of the knowledge graph</li> </ol> <pre><code># Agent discovers entities\ncreate_node(id=\"alice\", type=\"person\")\ncreate_node(id=\"project_x\", type=\"project\")\ncreate_node(id=\"rust\", type=\"language\")\n\n# Agent records a relationship\ncreate_edge(\n    nodes=[\"alice\", \"project_x\", \"rust\"],\n    type=\"works_on\",\n    source=\"conversation_2024_01_15\",\n    confidence=0.95\n)\n\n# Later: agent recalls what it knows about Alice\nsearch_edges(containing=[\"alice\"])\n\n# Agent explores connections\nget_neighbors(node_id=\"project_x\")\nfind_paths(start=\"alice\", end=\"rust\")\n</code></pre>"},{"location":"guides/provenance/","title":"Provenance","text":"<p>Every edge in Hypabase carries two provenance fields: <code>source</code> and <code>confidence</code>. These are first-class parts of the data model, not bolted-on metadata.</p>"},{"location":"guides/provenance/#setting-provenance-per-edge","title":"Setting provenance per-edge","text":"<pre><code>hb.edge(\n    [\"patient_123\", \"aspirin\", \"ibuprofen\"],\n    type=\"drug_interaction\",\n    source=\"clinical_decision_support_v3\",\n    confidence=0.92,\n)\n</code></pre> <p>If omitted, <code>source</code> defaults to <code>\"unknown\"</code> and <code>confidence</code> defaults to <code>1.0</code>.</p>"},{"location":"guides/provenance/#context-manager-for-bulk-provenance","title":"Context manager for bulk provenance","text":"<p>Use <code>hb.context()</code> to set default provenance for a block of operations:</p> <pre><code>with hb.context(source=\"clinical_records\", confidence=0.95):\n    hb.edge(\n        [\"dr_smith\", \"patient_a\", \"aspirin\", \"headache\", \"mercy_hospital\"],\n        type=\"treatment\",\n    )\n    hb.edge(\n        [\"dr_jones\", \"patient_b\", \"ibuprofen\", \"fever\"],\n        type=\"treatment\",\n    )\n# Both edges get source=\"clinical_records\", confidence=0.95\n</code></pre>"},{"location":"guides/provenance/#override-within-a-context","title":"Override within a context","text":"<p>Per-edge values override the context defaults:</p> <pre><code>with hb.context(source=\"extraction\", confidence=0.8):\n    hb.edge([\"a\", \"b\"], type=\"x\")                    # confidence=0.8\n    hb.edge([\"c\", \"d\"], type=\"y\", confidence=0.99)    # confidence=0.99\n</code></pre>"},{"location":"guides/provenance/#nested-contexts","title":"Nested contexts","text":"<p>Contexts can nest. The innermost context wins:</p> <pre><code>with hb.context(source=\"system_a\", confidence=0.9):\n    hb.edge([\"a\", \"b\"], type=\"x\")  # source=\"system_a\"\n\n    with hb.context(source=\"system_b\", confidence=0.7):\n        hb.edge([\"c\", \"d\"], type=\"y\")  # source=\"system_b\"\n\n    hb.edge([\"e\", \"f\"], type=\"z\")  # source=\"system_a\" (restored)\n</code></pre>"},{"location":"guides/provenance/#querying-by-provenance","title":"Querying by provenance","text":""},{"location":"guides/provenance/#filter-by-source","title":"Filter by source","text":"<pre><code>edges = hb.edges(source=\"clinical_records\")\n</code></pre>"},{"location":"guides/provenance/#filter-by-confidence-threshold","title":"Filter by confidence threshold","text":"<pre><code>high_confidence = hb.edges(min_confidence=0.9)\n</code></pre>"},{"location":"guides/provenance/#combine-provenance-with-other-filters","title":"Combine provenance with other filters","text":"<pre><code>edges = hb.edges(\n    containing=[\"patient_123\"],\n    source=\"clinical_records\",\n    min_confidence=0.9,\n)\n</code></pre>"},{"location":"guides/provenance/#aggregating-sources","title":"Aggregating sources","text":"<p>The <code>sources()</code> method provides an overview of all provenance sources:</p> <pre><code>sources = hb.sources()\n# [\n#     {\"source\": \"clinical_records\", \"edge_count\": 2, \"avg_confidence\": 0.95},\n#     {\"source\": \"lab_results\", \"edge_count\": 1, \"avg_confidence\": 0.88},\n# ]\n</code></pre> <p>Each entry includes:</p> <ul> <li><code>source</code> \u2014 the source string</li> <li><code>edge_count</code> \u2014 number of edges from this source</li> <li><code>avg_confidence</code> \u2014 mean confidence across all edges from this source</li> </ul>"},{"location":"guides/provenance/#use-cases","title":"Use cases","text":""},{"location":"guides/provenance/#multi-source-knowledge-graphs","title":"Multi-source knowledge graphs","text":"<p>Track which AI model, document, or human produced each fact:</p> <pre><code>with hb.context(source=\"gpt-4o_extraction\", confidence=0.85):\n    hb.edge([\"transformer\", \"attention\", \"nlp\"], type=\"concept_link\")\n\nwith hb.context(source=\"manual_review\", confidence=0.99):\n    hb.edge([\"transformer\", \"attention\", \"nlp\"], type=\"concept_link_verified\")\n</code></pre>"},{"location":"guides/provenance/#audit-trails","title":"Audit trails","text":"<p>Know exactly which source contributed each relationship:</p> <pre><code># What did the legal review say?\nlegal_edges = hb.edges(source=\"legal_review\")\n\n# What do we trust?\ntrusted = hb.edges(min_confidence=0.85)\n\n# What's unreliable?\nall_sources = hb.sources()\nlow_quality = [s for s in all_sources if s[\"avg_confidence\"] &lt; 0.7]\n</code></pre>"},{"location":"guides/provenance/#confidence-based-retrieval","title":"Confidence-based retrieval","text":"<p>In RAG pipelines, retrieve only high-confidence relationships:</p> <pre><code>edges = hb.edges(\n    containing=[\"query_entity\"],\n    min_confidence=0.8,\n)\n# Only facts we're confident about end up in the LLM context\n</code></pre>"},{"location":"guides/traversal/","title":"Traversal","text":"<p>Hypabase provides methods for navigating the hypergraph: finding neighbors, discovering paths, and querying incident edges.</p>"},{"location":"guides/traversal/#neighbors","title":"Neighbors","text":"<p>Find all nodes connected to a given node through any shared edge:</p> <pre><code>neighbors = hb.neighbors(\"patient_123\")\n# Returns list of Node objects connected to patient_123\n</code></pre>"},{"location":"guides/traversal/#filter-by-edge-type","title":"Filter by edge type","text":"<pre><code># Only neighbors connected via treatment edges\nneighbors = hb.neighbors(\"patient_123\", edge_types=[\"treatment\"])\n</code></pre> <p>The result excludes the query node itself.</p>"},{"location":"guides/traversal/#paths","title":"Paths","text":"<p>Find paths between two nodes through hyperedges:</p> <pre><code>paths = hb.paths(\"dr_smith\", \"mercy_hospital\")\n# [[\"dr_smith\", \"patient_123\", \"mercy_hospital\"], ...]\n</code></pre> <p>Each path is a list of node IDs from start to end.</p>"},{"location":"guides/traversal/#limit-hop-count","title":"Limit hop count","text":"<pre><code># Only short paths (up to 3 hops)\npaths = hb.paths(\"dr_smith\", \"mercy_hospital\", max_hops=3)\n</code></pre> <p>The default <code>max_hops</code> is 5.</p>"},{"location":"guides/traversal/#filter-by-edge-type_1","title":"Filter by edge type","text":"<pre><code># Only traverse treatment and diagnosis edges\npaths = hb.paths(\n    \"dr_smith\",\n    \"mercy_hospital\",\n    edge_types=[\"treatment\", \"diagnosis\"],\n)\n</code></pre>"},{"location":"guides/traversal/#advanced-path-finding","title":"Advanced path finding","text":"<p><code>find_paths()</code> provides intersection-constrained path finding \u2014 it returns paths as sequences of edges rather than node IDs, and supports set-based start/end nodes:</p> <pre><code>paths = hb.find_paths(\n    start_nodes={\"dr_smith\", \"dr_jones\"},\n    end_nodes={\"mercy_hospital\"},\n    max_hops=3,\n    max_paths=10,\n    edge_types=[\"treatment\"],\n)\n# Returns list of list[Edge]\n</code></pre> <p>Parameters:</p> <ul> <li><code>start_nodes</code> \u2014 set of possible start node IDs</li> <li><code>end_nodes</code> \u2014 set of possible end node IDs</li> <li><code>max_hops</code> \u2014 longest path length allowed (default 3)</li> <li><code>max_paths</code> \u2014 cap on paths returned (default 10)</li> <li><code>min_intersection</code> \u2014 required node overlap between consecutive edges (default 1)</li> <li><code>edge_types</code> \u2014 filter to specific edge types</li> <li><code>direction_mode</code> \u2014 <code>\"undirected\"</code> (default), <code>\"forward\"</code>, or <code>\"backward\"</code></li> </ul>"},{"location":"guides/traversal/#edges-of-a-node","title":"Edges of a node","text":"<p>Get all edges incident to a specific node:</p> <pre><code>edges = hb.edges_of_node(\"patient_123\")\n# All edges that include patient_123\n</code></pre> <p>Filter by edge type:</p> <pre><code>edges = hb.edges_of_node(\"patient_123\", edge_types=[\"treatment\"])\n</code></pre>"},{"location":"guides/traversal/#graph-metrics","title":"Graph metrics","text":""},{"location":"guides/traversal/#node-degree","title":"Node degree","text":"<p>Number of edges incident to a node:</p> <pre><code>degree = hb.node_degree(\"patient_123\")\n</code></pre> <p>Filter by edge type:</p> <pre><code>degree = hb.node_degree(\"patient_123\", edge_types=[\"treatment\"])\n</code></pre>"},{"location":"guides/traversal/#edge-cardinality","title":"Edge cardinality","text":"<p>Number of unique nodes in an edge:</p> <pre><code>cardinality = hb.edge_cardinality(edge_id)\n# 5 for a 5-node hyperedge\n</code></pre>"},{"location":"guides/traversal/#hyperedge-degree","title":"Hyperedge degree","text":"<p>Sum of vertex degrees of nodes in a given set:</p> <pre><code>degree = hb.hyperedge_degree({\"dr_smith\", \"patient_123\"})\n</code></pre>"},{"location":"reference/cli/","title":"CLI Reference","text":""},{"location":"reference/cli/#installation","title":"Installation","text":"<pre><code>uv add \"hypabase[cli]\"\n</code></pre>"},{"location":"reference/cli/#global-options","title":"Global options","text":"Option Default Description <code>--db PATH</code> <code>hypabase.db</code> Path to the SQLite database file"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#init","title":"<code>init</code>","text":"<p>Initialize a new Hypabase database.</p> <pre><code>hypabase init\nhypabase --db custom.db init\n</code></pre> <p>Creates the database file with the Hypabase schema. No-op if the file already exists.</p>"},{"location":"reference/cli/#node","title":"<code>node</code>","text":"<p>Create or update a node.</p> <pre><code>hypabase node ID [OPTIONS]\n</code></pre> Option Default Description <code>--type TEXT</code> <code>unknown</code> Node type <code>--props TEXT</code> <code>None</code> JSON string of properties <p>Examples:</p> <pre><code>hypabase node dr_smith --type doctor\nhypabase node dr_smith --type doctor --props '{\"specialty\": \"neurology\"}'\n</code></pre>"},{"location":"reference/cli/#edge","title":"<code>edge</code>","text":"<p>Create a hyperedge connecting two or more nodes.</p> <pre><code>hypabase edge NODE1 NODE2 [NODE3 ...] [OPTIONS]\n</code></pre> Option Default Description <code>--type TEXT</code> (required) Edge type <code>--source TEXT</code> <code>None</code> Provenance source <code>--confidence FLOAT</code> <code>None</code> Confidence score (0.0-1.0) <code>--props TEXT</code> <code>None</code> JSON string of properties <p>Examples:</p> <pre><code>hypabase edge dr_smith patient_123 aspirin --type treatment\nhypabase edge a b c --type link --source extraction --confidence 0.9\nhypabase edge a b --type rel --props '{\"weight\": 0.5}'\n</code></pre>"},{"location":"reference/cli/#query","title":"<code>query</code>","text":"<p>Query edges in the hypergraph.</p> <pre><code>hypabase query [OPTIONS]\n</code></pre> Option Default Description <code>--containing TEXT</code> (repeatable) Filter by node ID <code>--type TEXT</code> <code>None</code> Filter by edge type <code>--match-all</code> <code>False</code> Require all <code>--containing</code> nodes to be present <p>Examples:</p> <pre><code>hypabase query --containing patient_123\nhypabase query --containing patient_123 --containing aspirin --match-all\nhypabase query --type treatment\n</code></pre>"},{"location":"reference/cli/#stats","title":"<code>stats</code>","text":"<p>Show database statistics: node and edge counts by type.</p> <pre><code>hypabase stats\n</code></pre>"},{"location":"reference/cli/#validate","title":"<code>validate</code>","text":"<p>Check internal consistency of the hypergraph.</p> <pre><code>hypabase validate\n</code></pre>"},{"location":"reference/cli/#export-hif","title":"<code>export-hif</code>","text":"<p>Export the hypergraph to HIF (Hypergraph Interchange Format) JSON.</p> <pre><code>hypabase export-hif OUTPUT_PATH\n</code></pre>"},{"location":"reference/cli/#import-hif","title":"<code>import-hif</code>","text":"<p>Import a hypergraph from HIF JSON.</p> <pre><code>hypabase import-hif INPUT_PATH\nhypabase --db target.db import-hif INPUT_PATH\n</code></pre>"},{"location":"reference/client/","title":"Client API","text":""},{"location":"reference/client/#hypabase.client.Hypabase","title":"hypabase.client.Hypabase","text":"<p>A hypergraph database client.</p> <p>The primary interface for creating, querying, and traversing hypergraphs. Supports in-memory and local SQLite backends.</p> Constructor patterns <ul> <li><code>Hypabase()</code> \u2014 in-memory, ephemeral (SQLite <code>:memory:</code>)</li> <li><code>Hypabase(\"file.db\")</code> \u2014 local persistent SQLite file</li> <li><code>Hypabase(\"https://...\")</code> \u2014 cloud backend (Phase 3, raises NotImplementedError)</li> </ul> Example <pre><code>hb = Hypabase()                          # in-memory\nhb = Hypabase(\"myproject.db\")             # local SQLite file\n\n# Namespace isolation\ndrugs = hb.database(\"drugs\")\nsessions = hb.database(\"sessions\")\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.current_database","title":"current_database  <code>property</code>","text":"<pre><code>current_database: str\n</code></pre> <p>Current namespace name.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the database connection.</p> <p>Saves pending changes and releases the SQLite connection. No-op for in-memory instances.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persist current state to SQLite.</p> <p>No-op for in-memory instances. Normally called automatically after each mutation; use this for explicit manual saves.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.database","title":"database","text":"<pre><code>database(name: str) -&gt; Hypabase\n</code></pre> <p>Return a scoped view into a named namespace.</p> <p>The returned instance shares the same SQLite connection and stores dict, but reads/writes only the given namespace's data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Namespace name.</p> required <p>Returns:</p> Type Description <code>Hypabase</code> <p>A new Hypabase instance scoped to the namespace.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.databases","title":"databases","text":"<pre><code>databases() -&gt; list[str]\n</code></pre> <p>List all namespaces.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sorted list of namespace names.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.delete_database","title":"delete_database","text":"<pre><code>delete_database(name: str) -&gt; bool\n</code></pre> <p>Delete a namespace and all its data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Namespace to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the namespace existed, <code>False</code> otherwise.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.context","title":"context","text":"<pre><code>context(*, source: str, confidence: float = 1.0) -&gt; Generator[None, None, None]\n</code></pre> <p>Set default provenance for all edges created within the block.</p> <p>Edges created inside the context inherit <code>source</code> and <code>confidence</code> unless overridden per-edge. Contexts can be nested; the innermost wins.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Provenance source string (e.g., <code>\"gpt-4o_extraction\"</code>).</p> required <code>confidence</code> <code>float</code> <p>Default confidence score, 0.0-1.0.</p> <code>1.0</code> Example <pre><code>with hb.context(source=\"clinical_records\", confidence=0.95):\n    hb.edge([\"a\", \"b\"], type=\"link\")  # inherits provenance\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.node","title":"node","text":"<pre><code>node(id: str, *, type: str = 'unknown', **properties: Any) -&gt; Node\n</code></pre> <p>Create or update a node.</p> <p>If a node with the given ID exists, its type and properties are updated. Otherwise a new node is created.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique node identifier.</p> required <code>type</code> <code>str</code> <p>Node classification (e.g., <code>\"doctor\"</code>, <code>\"patient\"</code>).</p> <code>'unknown'</code> <code>**properties</code> <code>Any</code> <p>Arbitrary key-value metadata stored on the node.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Node</code> <p>The created or updated Node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>id</code> is an empty string.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.get_node","title":"get_node","text":"<pre><code>get_node(id: str) -&gt; Node | None\n</code></pre> <p>Get a node by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The node ID to look up.</p> required <p>Returns:</p> Type Description <code>Node | None</code> <p>The Node if found, or <code>None</code>.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.nodes","title":"nodes","text":"<pre><code>nodes(*, type: str | None = None) -&gt; list[Node]\n</code></pre> <p>Query nodes, optionally filtered by type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | None</code> <p>If provided, return only nodes of this type.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>List of matching nodes.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.find_nodes","title":"find_nodes","text":"<pre><code>find_nodes(**properties: Any) -&gt; list[Node]\n</code></pre> <p>Find nodes matching all specified properties.</p> <p>Parameters:</p> Name Type Description Default <code>**properties</code> <code>Any</code> <p>Key-value pairs that must match node properties.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>List of matching nodes.</p> Example <pre><code>hb.find_nodes(role=\"admin\", active=True)\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.has_node","title":"has_node","text":"<pre><code>has_node(id: str) -&gt; bool\n</code></pre> <p>Check if a node exists.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The node ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the node exists, <code>False</code> otherwise.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.delete_node","title":"delete_node","text":"<pre><code>delete_node(id: str, *, cascade: bool = False) -&gt; bool\n</code></pre> <p>Delete a node by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The node ID to delete.</p> required <code>cascade</code> <code>bool</code> <p>If <code>True</code>, also delete all incident edges.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the node existed and was deleted, <code>False</code> otherwise.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.delete_node_cascade","title":"delete_node_cascade","text":"<pre><code>delete_node_cascade(node_id: str) -&gt; tuple[bool, int]\n</code></pre> <p>Delete a node and all its incident edges.</p> <p>.. deprecated:: 0.2.0     Use <code>delete_node(id, cascade=True)</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The node ID to delete.</p> required <p>Returns:</p> Type Description <code>tuple[bool, int]</code> <p>Tuple of <code>(node_was_deleted, number_of_edges_deleted)</code>.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.edge","title":"edge","text":"<pre><code>edge(nodes: list[str], *, type: str, directed: bool = False, source: str | None = None, confidence: float | None = None, properties: dict[str, Any] | None = None, id: str | None = None) -&gt; Edge\n</code></pre> <p>Create a hyperedge linking two or more nodes in one relationship.</p> <p>Nodes are auto-created if they don't exist. Provenance values fall back to the active <code>context()</code> block if not set explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[str]</code> <p>Node IDs to connect. Must contain at least 2.</p> required <code>type</code> <code>str</code> <p>Edge type (e.g., <code>\"treatment\"</code>, <code>\"concept_link\"</code>).</p> required <code>directed</code> <code>bool</code> <p>If <code>True</code>, first node is tail, last is head.</p> <code>False</code> <code>source</code> <code>str | None</code> <p>Provenance source. Falls back to context or <code>\"unknown\"</code>.</p> <code>None</code> <code>confidence</code> <code>float | None</code> <p>Confidence score 0.0-1.0. Falls back to context or <code>1.0</code>.</p> <code>None</code> <code>properties</code> <code>dict[str, Any] | None</code> <p>Arbitrary key-value metadata.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>Optional edge ID. Auto-generated UUID if omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Edge</code> <p>The created Edge.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than 2 nodes or any node ID is empty.</p> Example <pre><code>hb.edge(\n    [\"dr_smith\", \"patient_123\", \"aspirin\"],\n    type=\"treatment\",\n    source=\"clinical_records\",\n    confidence=0.95,\n)\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.get_edge","title":"get_edge","text":"<pre><code>get_edge(id: str) -&gt; Edge | None\n</code></pre> <p>Get an edge by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The edge ID to look up.</p> required <p>Returns:</p> Type Description <code>Edge | None</code> <p>The Edge if found, or <code>None</code>.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.edges","title":"edges","text":"<pre><code>edges(*, containing: list[str] | None = None, type: str | None = None, match_all: bool = False, source: str | None = None, min_confidence: float | None = None) -&gt; list[Edge]\n</code></pre> <p>Query edges by contained nodes, type, source, and/or confidence.</p> <p>All filters are combined with AND logic.</p> <p>Parameters:</p> Name Type Description Default <code>containing</code> <code>list[str] | None</code> <p>Node IDs that must appear in the edge.</p> <code>None</code> <code>type</code> <code>str | None</code> <p>Filter to edges of this type.</p> <code>None</code> <code>match_all</code> <code>bool</code> <p>If <code>True</code>, edges must contain all nodes in <code>containing</code>. If <code>False</code> (default), any match suffices.</p> <code>False</code> <code>source</code> <code>str | None</code> <p>Filter to edges from this provenance source.</p> <code>None</code> <code>min_confidence</code> <code>float | None</code> <p>Filter to edges with confidence &gt;= this value.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Edge]</code> <p>List of matching edges.</p> Example <pre><code>hb.edges(containing=[\"patient_123\"], min_confidence=0.9)\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.find_edges","title":"find_edges","text":"<pre><code>find_edges(**properties: Any) -&gt; list[Edge]\n</code></pre> <p>Find edges matching all specified properties.</p> <p>Parameters:</p> Name Type Description Default <code>**properties</code> <code>Any</code> <p>Key-value pairs that must match edge properties.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Edge]</code> <p>List of matching edges.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.has_edge_with_nodes","title":"has_edge_with_nodes","text":"<pre><code>has_edge_with_nodes(node_ids: set[str], edge_type: str | None = None) -&gt; bool\n</code></pre> <p>Check if an edge with the exact vertex set exists.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>set[str]</code> <p>Exact set of node IDs.</p> required <code>edge_type</code> <code>str | None</code> <p>If provided, also filter by edge type.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if matching edge exists.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.sources","title":"sources","text":"<pre><code>sources() -&gt; list[dict[str, Any]]\n</code></pre> <p>Summarize provenance sources across all edges.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of dicts with keys <code>\"source\"</code>, <code>\"edge_count\"</code>,</p> <code>list[dict[str, Any]]</code> <p>and <code>\"avg_confidence\"</code> for each unique source.</p> Example <pre><code>hb.sources()\n# [{\"source\": \"clinical_records\", \"edge_count\": 2, \"avg_confidence\": 0.95}]\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.edges_by_vertex_set","title":"edges_by_vertex_set","text":"<pre><code>edges_by_vertex_set(nodes: list[str]) -&gt; list[Edge]\n</code></pre> <p>O(1) lookup: find edges with exactly this set of nodes.</p> <p>Uses the SHA-256 vertex-set hash index for constant-time lookup. Order of <code>nodes</code> does not matter.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[str]</code> <p>The exact set of node IDs to match.</p> required <p>Returns:</p> Type Description <code>list[Edge]</code> <p>Edges whose node set matches exactly.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.delete_edge","title":"delete_edge","text":"<pre><code>delete_edge(id: str) -&gt; bool\n</code></pre> <p>Delete an edge by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The edge ID to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the edge existed and was deleted, <code>False</code> otherwise.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.neighbors","title":"neighbors","text":"<pre><code>neighbors(node_id: str, *, edge_types: list[str] | None = None) -&gt; list[Node]\n</code></pre> <p>Find all nodes connected to the given node via shared edges.</p> <p>The query node itself is excluded from the results.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The node to find neighbors of.</p> required <code>edge_types</code> <code>list[str] | None</code> <p>If provided, only traverse edges of these types.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>List of neighboring nodes.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.paths","title":"paths","text":"<pre><code>paths(start: str, end: str, *, max_hops: int = 5, edge_types: list[str] | None = None) -&gt; list[list[str]]\n</code></pre> <p>Find paths between two nodes through hyperedges.</p> <p>Uses breadth-first search. Each path is a list of node IDs from <code>start</code> to <code>end</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>Starting node ID.</p> required <code>end</code> <code>str</code> <p>Target node ID.</p> required <code>max_hops</code> <code>int</code> <p>Maximum number of hops (default 5).</p> <code>5</code> <code>edge_types</code> <code>list[str] | None</code> <p>If provided, only traverse edges of these types.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>List of paths, where each path is a list of node IDs.</p> Example <pre><code>paths = hb.paths(\"dr_smith\", \"mercy_hospital\")\n# [[\"dr_smith\", \"patient_123\", \"mercy_hospital\"]]\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.find_paths","title":"find_paths","text":"<pre><code>find_paths(start_nodes: set[str], end_nodes: set[str], *, max_hops: int = 3, max_paths: int = 10, min_intersection: int = 1, edge_types: list[str] | None = None, direction_mode: str = 'undirected') -&gt; list[list[Edge]]\n</code></pre> <p>Find paths between two groups of nodes through shared edges.</p> <p>Returns paths as sequences of edges. Supports set-based start/end nodes and configurable overlap requirements.</p> <p>Parameters:</p> Name Type Description Default <code>start_nodes</code> <code>set[str]</code> <p>Set of possible starting node IDs.</p> required <code>end_nodes</code> <code>set[str]</code> <p>Set of possible ending node IDs.</p> required <code>max_hops</code> <code>int</code> <p>Maximum path length in edges (default 3).</p> <code>3</code> <code>max_paths</code> <code>int</code> <p>Maximum number of paths to return (default 10).</p> <code>10</code> <code>min_intersection</code> <code>int</code> <p>Minimum node overlap between consecutive edges (default 1).</p> <code>1</code> <code>edge_types</code> <code>list[str] | None</code> <p>If provided, only traverse edges of these types.</p> <code>None</code> <code>direction_mode</code> <code>str</code> <p><code>\"undirected\"</code> (default), <code>\"forward\"</code>, or <code>\"backward\"</code>.</p> <code>'undirected'</code> <p>Returns:</p> Type Description <code>list[list[Edge]]</code> <p>List of paths, where each path is a list of Edge objects.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.node_degree","title":"node_degree","text":"<pre><code>node_degree(node_id: str, *, edge_types: list[str] | None = None) -&gt; int\n</code></pre> <p>Count how many edges touch a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The node to measure.</p> required <code>edge_types</code> <code>list[str] | None</code> <p>If provided, only count edges of these types.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The degree (edge count) of the node.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.edge_cardinality","title":"edge_cardinality","text":"<pre><code>edge_cardinality(edge_id: str) -&gt; int\n</code></pre> <p>Count how many distinct nodes an edge contains.</p> <p>Parameters:</p> Name Type Description Default <code>edge_id</code> <code>str</code> <p>The edge to measure.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Count of distinct node IDs in the edge.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.hyperedge_degree","title":"hyperedge_degree","text":"<pre><code>hyperedge_degree(node_set: set[str], *, edge_type: str | None = None) -&gt; int\n</code></pre> <p>Add up the edge counts of every node in a set.</p> <p>Parameters:</p> Name Type Description Default <code>node_set</code> <code>set[str]</code> <p>Set of node IDs to aggregate.</p> required <code>edge_type</code> <code>str | None</code> <p>If provided, only count edges of this type.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Sum of individual node degrees.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.validate","title":"validate","text":"<pre><code>validate() -&gt; ValidationResult\n</code></pre> <p>Check the hypergraph for internal consistency.</p> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>A <code>ValidationResult</code> with <code>valid</code>, <code>errors</code>, and <code>warnings</code> fields.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.to_hif","title":"to_hif","text":"<pre><code>to_hif() -&gt; dict\n</code></pre> <p>Export the graph to HIF (Hypergraph Interchange Format).</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict representing the hypergraph in HIF JSON structure.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.from_hif","title":"from_hif  <code>classmethod</code>","text":"<pre><code>from_hif(hif_data: dict) -&gt; Hypabase\n</code></pre> <p>Build a new Hypabase instance from HIF (Hypergraph Interchange Format) data.</p> <p>Creates an in-memory instance populated from the HIF structure.</p> <p>Parameters:</p> Name Type Description Default <code>hif_data</code> <code>dict</code> <p>A dict in HIF JSON format.</p> required <p>Returns:</p> Type Description <code>Hypabase</code> <p>A new Hypabase instance containing the imported data.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.upsert_edge_by_vertex_set","title":"upsert_edge_by_vertex_set","text":"<pre><code>upsert_edge_by_vertex_set(node_ids: set[str], edge_type: str, properties: dict[str, Any] | None = None, *, source: str | None = None, confidence: float | None = None, merge_fn: Any = None) -&gt; Edge\n</code></pre> <p>Create or update an edge matched by its exact set of nodes.</p> <p>Finds an existing edge with the same nodes, or creates a new one. Useful for idempotent ingestion.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>set[str]</code> <p>Set of node IDs for the edge.</p> required <code>edge_type</code> <code>str</code> <p>Edge type string.</p> required <code>properties</code> <code>dict[str, Any] | None</code> <p>Key-value metadata. Merged on update.</p> <code>None</code> <code>source</code> <code>str | None</code> <p>Provenance source. Falls back to context or <code>\"unknown\"</code>.</p> <code>None</code> <code>confidence</code> <code>float | None</code> <p>Confidence score 0.0-1.0. Falls back to context or <code>1.0</code>.</p> <code>None</code> <code>merge_fn</code> <code>Any</code> <p>Optional callable <code>(existing_props, new_props) -&gt; merged_props</code> for custom property merging on update.</p> <code>None</code> <p>Returns:</p> Type Description <code>Edge</code> <p>The created or updated Edge.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.edges_of_node","title":"edges_of_node","text":"<pre><code>edges_of_node(node_id: str, *, edge_types: list[str] | None = None) -&gt; list[Edge]\n</code></pre> <p>Get all edges incident to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The node to query.</p> required <code>edge_types</code> <code>list[str] | None</code> <p>If provided, only return edges of these types.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Edge]</code> <p>List of edges containing this node.</p>"},{"location":"reference/client/#hypabase.client.Hypabase.batch","title":"batch","text":"<pre><code>batch() -&gt; Generator[None, None, None]\n</code></pre> <p>Group write operations and save them all at once.</p> <p>Reduces disk I/O for bulk inserts. Batches can nest; only the outermost batch triggers a save.</p> Note <p>Provides batched persistence, not transaction rollback. If an exception occurs mid-batch, partial in-memory changes remain and are persisted when the batch exits.</p> Example <pre><code>with hb.batch():\n    for i in range(1000):\n        hb.edge([f\"entity_{i}\", \"catalog\"], type=\"belongs_to\")\n# Single save at the end\n</code></pre>"},{"location":"reference/client/#hypabase.client.Hypabase.stats","title":"stats","text":"<pre><code>stats() -&gt; HypergraphStats\n</code></pre> <p>Get node and edge counts by type.</p> <p>Returns:</p> Type Description <code>HypergraphStats</code> <p>A <code>HypergraphStats</code> with <code>node_count</code>, <code>edge_count</code>,</p> <code>HypergraphStats</code> <p><code>nodes_by_type</code>, and <code>edges_by_type</code> fields.</p>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/models/#hypabase.models.Node","title":"hypabase.models.Node","text":"<p>               Bases: <code>BaseModel</code></p> <p>An entity in the hypergraph.</p> <p>Each node has an ID, a type for classification, and optional key-value properties. Nodes are auto-created when referenced in an edge.</p>"},{"location":"reference/models/#hypabase.models.Edge","title":"hypabase.models.Edge","text":"<p>               Bases: <code>BaseModel</code></p> <p>A hyperedge: one relationship linking two or more nodes.</p> <p>Each edge has a type, provenance (source and confidence), and can carry arbitrary properties. Node order within the edge is preserved.</p>"},{"location":"reference/models/#hypabase.models.Edge.node_ids","title":"node_ids  <code>property</code>","text":"<pre><code>node_ids: list[str]\n</code></pre> <p>Ordered list of node IDs (backward compat).</p>"},{"location":"reference/models/#hypabase.models.Edge.node_set","title":"node_set  <code>property</code>","text":"<pre><code>node_set: set[str]\n</code></pre> <p>Deduplicated set of node IDs.</p>"},{"location":"reference/models/#hypabase.models.Incidence","title":"hypabase.models.Incidence","text":"<p>               Bases: <code>BaseModel</code></p> <p>How a node or edge participates in a hyperedge.</p> <p>Each incidence links one node (or one edge reference) to an edge, with an optional direction. Exactly one of node_id or edge_ref_id must be set.</p>"},{"location":"reference/models/#hypabase.models.HypergraphStats","title":"hypabase.models.HypergraphStats","text":"<p>               Bases: <code>BaseModel</code></p> <p>Summary counts for a hypergraph database.</p> <p>Reports total node and edge counts, broken down by type.</p>"},{"location":"reference/models/#hypabase.models.ValidationResult","title":"hypabase.models.ValidationResult","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of a hypergraph consistency check.</p> <p>Contains a pass/fail flag, a list of errors, and a list of warnings found during validation.</p>"}]}